"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Revise = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const BASE_URL = "https://api.revise.network";
function getHeaders({ token }) {
    return {
        headers: {
            Authorization: `Bearer ${token}`,
        },
    };
}
const fetchCollectionsAPI = async ({ token }) => {
    const { data } = await axios_1.default.get(`${BASE_URL}/collections`, getHeaders({ token }));
    return data;
};
const fetchCollectionAPI = async ({ token, collectionId }) => {
    const { data } = await axios_1.default.get(`${BASE_URL}/collections/${collectionId}`, getHeaders({ token }));
    return data;
};
const addCollectionAPI = async ({ token, info }) => {
    const { data } = await axios_1.default.post(`${BASE_URL}/collections`, {
        collectionName: info.name,
        collectionURI: info.uri,
    }, getHeaders({ token }));
    return data;
};
const addNFTAPI = async ({ token, collectionId, info }) => {
    const tokenObj = {
        tokenId: info.tokenId,
        name: info.name,
        image: info.image,
        description: info.description,
        metaData: info.metaData,
    };
    if (collectionId) {
        const { data } = await axios_1.default.post(`${BASE_URL}/collections/${collectionId}/nfts`, tokenObj, getHeaders({ token }));
        return data;
    }
    const { data } = await axios_1.default.post(`${BASE_URL}/nfts/addnft`, tokenObj, getHeaders({ token }));
    return data;
};
const updateNFTAPI = async ({ token, nftId, info }) => {
    const { data } = await axios_1.default.put(`${BASE_URL}/nfts/${nftId}`, {
        tokenId: info.tokenId,
        name: info.name,
        image: info.image,
        description: info.description,
        metaData: info.metaData,
    }, getHeaders({ token }));
    return data;
};
const fetchCollectionNFTsAPI = async ({ token, collectionId }) => {
    const { data } = await axios_1.default.get(`${BASE_URL}/collections/${collectionId}/nfts`, getHeaders({ token }));
    return data.map((nft) => {
        try {
            const nftEntity = Object.assign(Object.assign({}, nft), { metaData: JSON.parse(nft.metaData) });
            if (nftEntity.id) {
                return Object.assign(Object.assign({}, nftEntity), { message: 'ID exists' });
            }
            return nftEntity;
        }
        catch (error) {
            const nftEntity = Object.assign(Object.assign({}, nft), { metaData: [] });
            return nftEntity;
        }
    });
};
const fetchNFTsAPI = async ({ token, collectionId }) => {
    const { data } = await axios_1.default.get(`${BASE_URL}/nfts`, getHeaders({ token }));
    return data.map((nft) => {
        try {
            const nftEntity = Object.assign(Object.assign({}, nft), { metaData: JSON.parse(nft.metaData) });
            if (nftEntity.id) {
                return Object.assign(Object.assign({}, nftEntity), { message: 'ID exists' });
            }
            return nftEntity;
        }
        catch (error) {
            const nftEntity = Object.assign(Object.assign({}, nft), { metaData: [] });
            return nftEntity;
        }
    });
};
const fetchNFTAPI = async ({ token, nftId }) => {
    const { data } = await axios_1.default.get(`${BASE_URL}/nfts/${nftId}`, getHeaders({ token }));
    try {
        data.metaData = JSON.parse(data.metaData);
    }
    catch (error) {
        data.metaData = {};
    }
    return data;
};
const fetchRevisionsAPI = async ({ token, nftId }) => {
    const { data } = await axios_1.default.get(`${BASE_URL}/nfts/${nftId}/revisions`, getHeaders({ token }));
    try {
        data.metaData = JSON.parse(data.metaData);
        data.revisions = data.revisions.map(rev => {
            try {
                rev.metaData = JSON.parse(rev.metaData);
            }
            catch (error) {
                rev.metaData = [];
            }
            return rev;
        });
        return data;
    }
    catch (error) {
        throw {
            response: { data: { code: "INVMD", message: "Invalid metadata" } },
        };
    }
};
const deleteNFTAPI = async ({ token, tokenId }) => {
    const { data } = await axios_1.default.delete(`${BASE_URL}/nfts/${tokenId}`, getHeaders({ token }));
    return data;
};
class NFTObj {
    constructor({ auth, nft }) {
        this.auth = auth;
        this.nft = nft;
    }
    metaDataAsMap() {
        return this.nft.metaData.reduce((newObj, cur) => {
            if (!newObj)
                newObj = {};
            newObj[Object.keys(cur)[0]] = cur[Object.keys(cur)[0]];
            return newObj;
        });
    }
    setMetaData(obj) {
        const d = Object.keys(obj).map((key) => {
            const newObj = {};
            newObj[key] = obj[key];
            return newObj;
        });
        this.nft.metaData = d;
    }
    setProperty(key, value) {
        const metaData = this.metaDataAsMap();
        // let isNewProperty = true;
        // this.nft.metaData = this.nft.metaData.map((attr: Attribute) => {
        //   const temp = {...attr};
        //   if (Object.keys(temp)[0] === key) {
        //     isNewProperty = false;
        //     temp[key] = value;
        //   }
        //   return temp;
        // })
        // if (isNewProperty) {
        //   const o = {};
        //   o[key] = value;
        //   this.nft.metaData.push(o);
        // }
        metaData[key] = value;
        this.setMetaData(metaData);
        return this;
    }
    deleteProperty(key) {
        this.nft.metaData = this.nft.metaData.filter((attr) => Object.keys(attr)[0] !== key);
        return this;
    }
    setName(name) {
        this.nft.name = name;
        return this;
    }
    setImage(image) {
        this.nft.image = image;
        return this;
    }
    setTokenId(tokenId) {
        this.nft.tokenId = tokenId;
        return this;
    }
    setDescription(description) {
        this.nft.description = description;
        return this;
    }
    save() {
        return updateNFTAPI({
            token: this.auth,
            nftId: this.nft.id,
            info: {
                tokenId: this.nft.tokenId,
                name: this.nft.name,
                image: this.nft.image,
                description: this.nft.description,
                metaData: this.nft.metaData
            }
        });
    }
    // export() {
    //   return "ipfs://...";
    // }
    async revisions() {
        return (await fetchRevisionsAPI({ token: this.auth, nftId: this.nft.id })).revisions;
    }
    async revisionsLink() {
        return `https://revise.link/revision/${this.nft.id}`;
    }
}
class Revise {
    constructor({ auth }) {
        this.auth = auth;
    }
    fetchCollections() {
        return fetchCollectionsAPI({ token: this.auth });
    }
    fetchCollection(collectionId) {
        return fetchCollectionAPI({ token: this.auth, collectionId });
    }
    addCollection({ name, uri }) {
        return addCollectionAPI({ token: this.auth, info: { name, uri } });
    }
    addNFT(tokenData, properties, collectionId) {
        const { tokenId, name, image, description } = tokenData;
        const info = {
            tokenId,
            name,
            image,
            description: description || "",
            metaData: properties
        };
        if (collectionId) {
            return addNFTAPI({ token: this.auth, collectionId, info });
        }
        return addNFTAPI({ token: this.auth, info });
    }
    async updateNFT(nftId) {
        return this.nft(await this.fetchNFT(nftId));
    }
    nft(nft) {
        return new NFTObj({ auth: this.auth, nft });
    }
    fetchNFTs(collectionId) {
        if (collectionId === undefined || collectionId === null) {
            return fetchNFTsAPI({ token: this.auth, collectionId });
        }
        return fetchCollectionNFTsAPI({ token: this.auth, collectionId });
    }
    fetchNFT(nftId) {
        return fetchNFTAPI({ token: this.auth, nftId });
    }
    deleteNFT(nftId) {
        return deleteNFTAPI({ token: this.auth, tokenId: nftId });
    }
    fetchRevisions(nftId) {
        return fetchRevisionsAPI({ token: this.auth, nftId });
    }
    every(durationString) {
        return new Automation(new Duration(durationString));
    }
}
exports.Revise = Revise;
class Automation {
    constructor(duration) {
        this.duration = duration;
    }
    listenTo(api) {
        if (typeof api !== 'string' && typeof api !== 'function') {
            throw new Error('invalid API source shared');
        }
        if (typeof api === 'string') {
            this.apiResolver = async () => (await axios_1.default.get(api)).data;
        }
        if (typeof api === 'function') {
            this.apiResolver = api;
        }
        return this;
    }
    async start(cb) {
        const data = await this.apiResolver();
        cb(data);
        setTimeout(() => {
            this.start(cb);
        }, this.duration.getMiliseconds());
    }
}
class Duration {
    constructor(durationString) {
        this.durationString = durationString;
    }
    getMiliseconds() {
        try {
            if (this.durationString.toLowerCase().includes('s')) {
                const data = this.durationString.toLowerCase().split('m')[0];
                return parseInt(data) * 1000;
            }
            if (this.durationString.toLowerCase().includes('m')) {
                const data = this.durationString.toLowerCase().split('m')[0];
                return parseInt(data) * 60000;
            }
            if (this.durationString.toLowerCase().includes('h')) {
                const data = this.durationString.toLowerCase().split('m')[0];
                return parseInt(data) * 3600000;
            }
        }
        catch (error) {
            throw new Error("Invalid time format passed");
        }
    }
}
//# sourceMappingURL=index.js.map